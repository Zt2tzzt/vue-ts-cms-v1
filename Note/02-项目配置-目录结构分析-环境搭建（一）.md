# 一、项目代码规范配置

## 1.”.editorconfig“ 文件

用于 editorconfig 配置，作用是在不同的编辑器之间，保持统一的代码风格。

./.editorconfig

```yaml
# http://editorconfig.org

root = true # 配置文件在项目根目录

[*] # 表示所有文件适用
charset = utf-8 # 设置文件字符集为 utf-8
indent_style = tab # 缩进风格（tab | space）
indent_size = 2 # 缩进大小
end_of_line = lf # 控制换行类型(lf | cr | crlf)
trim_trailing_whitespace = true # 去除行尾的任意空白字符
insert_final_newline = true # 始终在文件末尾插入一个新行

[*.md] # 表示仅 md 文件适用以下规则
max_line_length = off
```

编辑器（如 VSCode）还需要安装一个插件（如 *EditorConfig for VS Code*）

## 2.“.prettierrc.json” 文件

用于 prettier 的配置，主要作用是格式化代码，前端用到的大部分文件格式，都能处理。

prettier 使用步骤：

1.安装 prettier

```shell
npm install prettier -D
```

2.配置 `.prettierrc` ⽂件，与 editorconfig 的配置保持统一。

./.prettierrc.json（“.json” 或者 “rc” 后缀，效果都一样）

```json
{
  "useTabs": true,
  "tabWidth": 2, // tab 占⼏个空格
  "printWidth": 100, // 当⾏字符的⻓度。
  "singleQuote": true, // 使⽤单引号还是双引号，默认 false
  "trailingComma": "none", // 最后一⾏末尾逗号是否添加，设置为 none
  "semi": false, // 语句末尾是否要加分号，默认值 true，选择 false 表示不加；
  "arrowParens": "avoid" // 箭头函数单个参数，不用括号
}
```

> 项目中安装的 prettier 依赖，需要在命令行中执行命令，才嫩生效。
>
> 如果想要在编辑器（如 VSCode）中（保存文件时）使用 prettier 格式化，需要安装 *Prettier - Code formatter* 插件。并在 VSCode 中进行设置：
>
> - Editor: Formart On Save - 勾选；表示文件保存时，进行格式化。
> - Editor: Default Format - 选择 Prettier，表示默认使用 prettier 进行格式化。
>
> 编辑器中的 prettier 插件，会读取项目中 `.prettierrc` 配置文件。覆盖编辑器里的设值项。

3.在 `package.json` 的 `script` 选项中，配置 prettier 的执行命令：

```json
"prettier": "prettier --write ."
```

## 3.“.prettierignore” 文件

prettier 忽略的文件。

./.prettierignore

```yaml
/dist/*
.local
.output.js
/node_modules/**

**/*.svg
**/*.sh

/public/*
```

## 4.“.eslintrc.cjs” 文件

用于 *eslint* 的配置，用于在编写代码时做检测，当写出不规范的代码时，报警告。

使用脚手架创建 vue 项目时，已经安装并初步配置了 eslint 依赖。

> 与 prettier 同理，安装 eslint 依赖，需要在命令行中执行命令，才嫩生效。
>
> 如果想要在编辑器（如 VSCode）中（编写代码时）实时的看到代码不规范的报错，需要安装 eslint 插件。

eslint 使用步骤：

1.安装插件

```shell
npm install eslint-plugin-prettier -D

# npm install eslint-config-prettier -D # vue 脚手架安装过了
```

2.配置 `.eslintrc.cjs` 文件，消除与 *prettier* 的冲突。

```js
/* eslint-env node */
require('@rushstack/eslint-patch/modern-module-resolution')

module.exports = {
	extends: [
    // ...
		'@vue/eslint-config-prettier',
		'plugin:prettier/recommended'
	],
}
```

3.关闭对某些规则的检测，比如关闭对不明确的 any 类型的语法检测。

```js
require('@rushstack/eslint-patch/modern-module-resolution')

module.exports = {
	rules: {
		'@typescript-eslint/no-explicit-any': 'off',
	}
}
```

# 二、项目目录结构划分

```shell
src：
  ├─assets
  ├─base-ui
  ├─components
  ├─global # 用于存放需要全局安装的插件
  ├─hooks
  ├─router
  ├─service
  ├─stores
  ├─types # 用于存放多处都会用到的类型
  ├─utils
  └─views
```

# 三、CSS 预处理器

安装 less 预处理器

```shell
npm install less -D
```

# 四、CSS 重置

## 1.normalize.css 安装

```shell
npm install normalize.css
```

## 2.reset.less 编写

src\assets\css\reset.less

```less
/* reset.css样式重置文件 */
/* margin/padding重置 */
body, h1, h2, h3, ul, ol, li, p, dl, dt, dd {
  padding: 0;
  margin: 0;
}

/* a元素重置 */
a {
  text-decoration: none;
  color: #333;
}

/* img的vertical-align重置 */
img {
  vertical-align: top;
}

/* ul, ol, li重置 */
ul, ol, li {
  list-style: none;
}

/* 对斜体元素重置 */
i, em {
  font-style: normal;
}
```

## 3.重置样式引入

将重置样式的代码，引入到 `main.ts`

```typescript
import 'normalize.css'
import './assets/css/index.less'
```

# 五、路由配置

## 1.两个主页面创建

登录页面

src\views\login\Login.vue

Main 页面

src\views\main\Home.vue

## 2.NotFound 页面创建

NotFound 创建

src\views\not-found\NotFound.vue

## 3.配置文件

src\router\index.ts

```typescript
import { createRouter, createWebHashHistory } from 'vue-router'

const router = createRouter({
	history: createWebHashHistory(import.meta.env.BASE_URL),
	routes: [
		{
			path: '/',
			redirect: '/main'
		},
		{
			path: '/login',
			component: () => import('../views/login/Login.vue')
		},
		{
			path: '/main',
			component: () => import('../views/main/Main.vue')
		},
		{
			path: '/:pathMatch(.*)',
			component: () => import('../views/not-found/NotFound.vue')
		}
	]
})

export default router
```

> VSCode 右下角 volar 插件可设值组件编写的风格

## 4.在 App.vue 中使用

src\App.vue

```vue
<script setup lang="ts"></script>

<template>
	<div class="app">
		<h1>app</h1>
		<router-link to="/main">主题</router-link>
		<router-link to="/login">登录</router-link>

		<router-view></router-view>
	</div>
</template>

<style scoped lang="less"></style>
```



# 六、状态管理

使用 Pinia 进行状态管理。

## 1.pinia 创建和安装

创建

src\stores\index.ts

```typescript
import { createPinia } from 'pinia';

const pinia = createPinia()
export default pinia
```

安装

src\main.ts

```typescript
import pinia from './stores'
// ...
app.use(pinia)
```

## 2.状态定义

src\stores\counter.ts

```typescript
import { defineStore } from 'pinia';

const useCounterStore = defineStore('counter', {
	state: () => ({
		counter: 100
	}),
	getters: {
		doubleCounter(state) {
			return state.counter * 2
		}
	},
	actions: {
		changeCounterAction(newCounter: number) {
			this.counter = newCounter
		}
	}
})

export default useCounterStore
```

## 3.在 Main.vue 中使用

src\views\main\Main.vue

```vue
<script setup lang="ts">
import useCounterStore from '@/stores/counter'

const counterStore = useCounterStore()
const onBtnClick = () => counterStore.changeCounterAction(999)
</script>

<template>
	<div class="Main">
		<h2>main: {{ counterStore.counter }}-{{ counterStore.doubleCounter }}</h2>
		<button @click="onBtnClick">修改 counter</button>
	</div>
</template>

<style scoped lang="less"></style>
```



# 七、网络请求封装

## 1.axios 库安装

```shell
npm install axios
```

## 2.封装

引入封装好的 axios 网络请求。

src\service\request\index.ts

区分隐式 any 与匿名函数参数类型上下文推导。

```typescript
this.instance
  .request<any, T>(config)
  // res 是匿名函数中的参数，类型由上下文推导，而不是隐式的 any 类型
  .then(res => {
    if (config.interceptor?.responseInterceptor) {
      res = config.interceptor.responseInterceptor(res)
    }
    this.showLoading = DEFAULT_LOADING
    resolve(res)
  })
  .catch(err => {
    this.showLoading = DEFAULT_LOADING
    reject(err)
  })
```

# 八、开发/生产环境区分

## 1.方式一：手动区分

通过手动注释代码的形式，区分生成环境和开发环境中的网络请求地址等信息。

src\service\request\config.ts

```typescript
// 方式一，手动切换不同环境
export const BASE_URL = 'http://codercba.dev:8000'
//export const BASE_URL = 'http://codercba.prod:8000'
```

## 2.方式二：vite 环境变量区分

Vite 在一个特殊的对象 `import.meta.env` 上暴露环境变量。这里有一些在所有情况下都可以使用的内建变量：
- `import.meta.env.MODE`: {string} 应用运行的模式。
- `import.meta.env.PROD`: {boolean} 应用是否运行在生产环境。
- `import.meta.env.DEV`: {boolean} 应用是否运行在开发环境 (永远与 `import.meta.env.PROD` 相反)。
- `import.meta.env.SSR`: {boolean} 应用是否运行在 server 上。

src\service\request\config.ts

```typescript
let BASE_URL: string

switch (import.meta.env.PROD) {
	case true:
		BASE_URL = 'http://codercba.prod:8000'
		break
	case false:
		BASE_URL = 'http://codercba.dev:8000'
		break
}

export { BASE_URL }
```

> 使用 `preview` 命令，预览打包后项目的运行效果，此时处于生产环境中。

## 3.方式三：vite dotenv 文件区分

Vite 使用 dotenv 从项目环境目录中的下列文件加载额外的环境变量：

```shell
├─.env # 所有情况下，都会加载
├─.env.local # 所有情况下，都会加载，会被 git 忽略
├─.env.[mode] # 只有指定模式下加载
└─.env.[mode].local # 只有指定模式下加载，会被 git 忽略
```

有以 `VITE_` 为前缀的变量才会暴露给经过 vite 处理的代码。

./.env

```
VITE_NAME=ZZT
```

./.env.development

```
VITE_URL=dev
```

./.env.production

```
VITE_URL=prd
```

src\service\request\config.ts

```typescript
console.log('VITE_NAME:', import.meta.env.VITE_NAME) // 生成/开发环境：ZZT
console.log('VITE_URL:', import.meta.env.VITE_URL) // 生产环境：prd；开发环境：dev
```

